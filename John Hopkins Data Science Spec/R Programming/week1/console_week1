
> x[!is.na(x) & x > 0]
 [1] 0.4737058 0.8639858 0.3924404 1.2857644 0.4852165 0.7083184 0.8603818 0.3546538 0.7699932 0.4841616 0.7229792 0.2196495 0.6601551 0.9639860 1.9606594

| Perseverance, that's the answer.

  |=====================================================================                                                                                         |  44%
| In this case, we request only values of x that are both non-missing AND greater than zero.

...

  |=========================================================================                                                                                     |  46%
| I've already shown you how to subset just the first ten values of x using x[1:10]. In this case, we're providing a vector of positive integers inside of the square
| brackets, which tells R to return only the elements of x numbered 1 through 10.

...

  |=============================================================================                                                                                 |  49%
| Many programming languages use what's called 'zero-based indexing', which means that the first element of a vector is considered element 0. R uses 'one-based
| indexing', which (you guessed it!) means the first element of a vector is considered element 1.

...

  |=================================================================================                                                                             |  51%
| Can you figure out how we'd subset the 3rd, 5th, and 7th elements of x? Hint -- Use the c() function to specify the element numbers as a numeric vector.

> x[c(3,5,7)]
[1] NA NA NA

| You are doing so well!

  |=====================================================================================                                                                         |  54%
| It's important that when using integer vectors to subset our vector x, we stick with the set of indexes {1, 2, ..., 40} since x only has 40 elements. What happens if
| we ask for the zeroth element of x (i.e. x[0])? Give it a try.

> x[0]
numeric(0)

| Keep up the great work!

  |=========================================================================================                                                                     |  56%
| As you might expect, we get nothing useful. Unfortunately, R doesn't prevent us from doing this. What if we ask for the 3000th element of x? Try it out.

> x[3000]
[1] NA

| You got it!

  |=============================================================================================                                                                 |  59%
| Again, nothing useful, but R doesn't prevent us from asking for it. This should be a cautionary tale. You should always make sure that what you are asking for is
| within the bounds of the vector you're working with.

...

  |=================================================================================================                                                             |  62%
| What if we're interested in all elements of x EXCEPT the 2nd and 10th? It would be pretty tedious to construct a vector containing all numbers 1 through 40 EXCEPT 2
| and 10.

...

  |=====================================================================================================                                                         |  64%
| Luckily, R accepts negative integer indexes. Whereas x[c(2, 10)] gives us ONLY the 2nd and 10th elements of x, x[c(-2, -10)] gives us all elements of x EXCEPT for
| the 2nd and 10 elements.  Try x[c(-2, -10)] now to see this.

> x[c(-2,-10)]
 [1]  0.4737058         NA         NA         NA -1.5834012         NA         NA         NA         NA         NA         NA         NA         NA -0.4550004
[15]         NA  1.2857644  0.4852165  0.7083184         NA  0.8603818         NA         NA  0.3546538         NA         NA  0.7699932  0.4841616 -2.2237091
[29]  0.7229792         NA  0.2196495 -2.9252199  0.6601551 -0.9479075  0.9639860         NA  1.9606594         NA

| You are doing so well!

  |=========================================================================================================                                                     |  67%
| A shorthand way of specifying multiple negative numbers is to put the negative sign out in front of the vector of positive numbers. Type x[-c(2, 10)] to get the
| exact same result.

> x[-c(2,10)]
 [1]  0.4737058         NA         NA         NA -1.5834012         NA         NA         NA         NA         NA         NA         NA         NA -0.4550004
[15]         NA  1.2857644  0.4852165  0.7083184         NA  0.8603818         NA         NA  0.3546538         NA         NA  0.7699932  0.4841616 -2.2237091
[29]  0.7229792         NA  0.2196495 -2.9252199  0.6601551 -0.9479075  0.9639860         NA  1.9606594         NA

| Excellent work!

  |=============================================================================================================                                                 |  69%
| So far, we've covered three types of index vectors -- logical, positive integer, and negative integer. The only remaining type requires us to introduce the concept
| of 'named' elements.

...

  |=================================================================================================================                                             |  72%
| Create a numeric vector with three named elements using vect <- c(foo = 11, bar = 2, norf = NA).

> vect <- c(foo = 11, bar = 2, norf = NA)

| Keep working like that and you'll get there!

  |=====================================================================================================================                                         |  74%
| When we print vect to the console, you'll see that each element has a name. Try it out.

> vect
 foo  bar norf 
  11    2   NA 

| You are amazing!

  |==========================================================================================================================                                    |  77%
| We can also get the names of vect by passing vect as an argument to the names() function. Give that a try.

> names(vect)
[1] "foo"  "bar"  "norf"

| Your dedication is inspiring!

  |==============================================================================================================================                                |  79%
| Alternatively, we can create an unnamed vector vect2 with c(11, 2, NA). Do that now.

> vect2 <- c(11,2,NA)

| You are amazing!

  |==================================================================================================================================                            |  82%
| Then, we can add the `names` attribute to vect2 after the fact with names(vect2) <- c("foo", "bar", "norf"). Go ahead.

> names(vect2) <- c("foo", "bar", "norf")

| Keep working like that and you'll get there!

  |======================================================================================================================================                        |  85%
| Now, let's check that vect and vect2 are the same by passing them as arguments to the identical() function.

> identical(vect1,vect2)
Error in identical(vect1, vect2) : object 'vect1' not found
> identical(vect,vect2)
[1] TRUE

| Keep up the great work!

  |==========================================================================================================================================                    |  87%
| Indeed, vect and vect2 are identical named vectors.

...

  |==============================================================================================================================================                |  90%
| Now, back to the matter of subsetting a vector by named elements. Which of the following commands do you think would give us the second element of vect?

1: vect[bar]
2: vect["2"]
3: vect["bar"]

Selection: 1

| Not quite, but you're learning! Try again.

| If we want the element named "bar" (i.e. the second element of vect), which command would get us that?

1: vect["2"]
2: vect["bar"]
3: vect[bar]

Selection: 3

| Give it another try.

| If we want the element named "bar" (i.e. the second element of vect), which command would get us that?

1: vect["bar"]
2: vect[bar]
3: vect["2"]

Selection: 1

| You are really on a roll!

  |==================================================================================================================================================            |  92%
| Now, try it out.

> vect["bar"]
bar 
  2 

| Excellent work!

  |======================================================================================================================================================        |  95%
| Likewise, we can specify a vector of names with vect[c("foo", "bar")]. Try it out.

> vect[c("foo","bar")]
foo bar 
 11   2 

| Excellent job!

  |==========================================================================================================================================================    |  97%
| Now you know all four methods of subsetting data from vectors. Different approaches are best in different scenarios and when in doubt, try it out!

...

  |==============================================================================================================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: Yes
2: No

Selection: yes
Enter an item from the menu, or 0 to exit
Selection: 1
What is your email address? 

| Leaving swirl now. Type swirl() to resume.

> swirl()

| Welcome to swirl! Please sign in. If you've been here before, use the same name as you did then. If you are new, call yourself something unique.

What shall I call you? Sean

| Would you like to continue with one of these lessons?

1: R Programming Subsetting Vectors
2: No. Let me start something new.

Selection: 2

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values          
 6: Subsetting Vectors         7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data           13: Simulation                14: Dates and Times           15: Base Graphics           


Selection: 7

  |                                                                                                                                                              |   0%

| In this lesson, we'll cover matrices and data frames. Both represent 'rectangular' data types, meaning that they are used to store tabular data, with rows and
| columns.

...

  |====                                                                                                                                                          |   3%
| The main difference, as you'll see, is that matrices can only contain a single class of data, while data frames can consist of many
| different classes of data.

...

  |=========                                                                                                                                                     |   6%
| Let's create a vector containing the numbers 1 through 20 using the `:` operator. Store the result in a variable called my_vector.

> 
> x <- 1:20

| Not quite! Try again. Or, type info() for more options.

| You learned about the `:` operator in the lesson on sequences. If you wanted to create a vector containing the numbers 1, 2, and 3 (in
| that order), you could use either c(1, 2, 3) or 1:3. In this case, we want the numbers 1 through 20 stored in a variable called
| my_vector. Also, remember that you don't need the c() function when using `:`.

> x <- c(1:20)

| You almost had it, but not quite. Try again. Or, type info() for more options.

| You learned about the `:` operator in the lesson on sequences. If you wanted to create a vector containing the numbers 1, 2, and 3 (in
| that order), you could use either c(1, 2, 3) or 1:3. In this case, we want the numbers 1 through 20 stored in a variable called
| my_vector. Also, remember that you don't need the c() function when using `:`.

> 1:20
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

| Not quite, but you're learning! Try again. Or, type info() for more options.

| You learned about the `:` operator in the lesson on sequences. If you wanted to create a vector containing the numbers 1, 2, and 3 (in
| that order), you could use either c(1, 2, 3) or 1:3. In this case, we want the numbers 1 through 20 stored in a variable called
| my_vector. Also, remember that you don't need the c() function when using `:`.

> my_vector <- 1:20

| You're the best!

  |=============                                                                                                                                                 |   8%
| View the contents of the vector you just created.

> my_vector
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

| You are amazing!

  |==================                                                                                                                                            |  11%
| The dim() function tells us the 'dimensions' of an object. What happens if we do dim(my_vector)? Give it a try.

> dim(my_vector)
NULL

| Nice work!

  |======================                                                                                                                                        |  14%
| Clearly, that's not very helpful! Since my_vector is a vector, it doesn't have a `dim` attribute (so it's just NULL), but we can find
| its length using the length() function. Try that now.

> length(my_vector)
[1] 20

| You are doing so well!

  |==========================                                                                                                                                    |  17%
| Ah! That's what we wanted. But, what happens if we give my_vector a `dim` attribute? Let's give it a try. Type dim(my_vector) <- c(4,
| 5).

> dim(my_vector) <- c(4,5)

| That's correct!

  |===============================                                                                                                                               |  19%
| It's okay if that last command seemed a little strange to you. It should! The dim() function allows you to get OR set the `dim`
| attribute for an R object. In this case, we assigned the value c(4, 5) to the `dim` attribute of my_vector.

...

  |===================================                                                                                                                           |  22%
| Use dim(my_vector) to confirm that we've set the `dim` attribute correctly.

> dim(my_vector)
[1] 4 5

| You nailed it! Good job!

  |========================================                                                                                                                      |  25%
| Another way to see this is by calling the attributes() function on my_vector. Try it now.

> attributes(my_vector)
$dim
[1] 4 5


| You are quite good my friend!

  |============================================                                                                                                                  |  28%
| Just like in math class, when dealing with a 2-dimensional object (think rectangular table), the first number is the number of rows and
| the second is the number of columns. Therefore, we just gave my_vector 4 rows and 5 columns.

...

  |================================================                                                                                                              |  31%
| But, wait! That doesn't sound like a vector any more. Well, it's not. Now it's a matrix. View the contents of my_vector now to see what
| it looks like.

> my_vector
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20

| You nailed it! Good job!

  |=====================================================                                                                                                         |  33%
| Now, let's confirm it's actually a matrix by using the class() function. Type class(my_vector) to see what I mean.

> class(my_vector)
[1] "matrix"

| You are doing so well!

  |=========================================================                                                                                                     |  36%
| Sure enough, my_vector is now a matrix. We should store it in a new variable that helps us remember what it is. Store the value of
| my_vector in a new variable called my_matrix.

> my_matrix <- my_vector

| All that hard work is paying off!

  |=============================================================                                                                                                 |  39%
| The example that we've used so far was meant to illustrate the point that a matrix is simply an atomic vector with a dimension
| attribute. A more direct method of creating the same matrix uses the matrix() function.

...

  |==================================================================                                                                                            |  42%
| Bring up the help file for the matrix() function now using the `?` function.

> ?
+ matrix()

| Almost! Try again. Or, type info() for more options.

| The command ?matrix will do the trick.

> ?matrix

| You are really on a roll!

  |======================================================================                                                                                        |  44%
| Now, look at the documentation for the matrix function and see if you can figure out how to create a matrix containing the same numbers
| (1-20) and dimensions (4 rows, 5 columns) by calling the matrix() function. Store the result in a variable called my_matrix2.

> my_matrix2 <- matrix(data=1:20,nrow=4,ncol=5)

| Excellent job!

  |===========================================================================                                                                                   |  47%
| Finally, let's confirm that my_matrix and my_matrix2 are actually identical. The identical() function will tell us
| if its first two arguments are the same. Try it out.

> identical(my_matrix,my_matrix2)
[1] TRUE

| You are amazing!

  |===============================================================================                                                                               |  50%
| Now, imagine that the numbers in our table represent some measurements from a clinical experiment, where each row
| represents one patient and each column represents one variable for which measurements were taken.

...

  |===================================================================================                                                                           |  53%
| We may want to label the rows, so that we know which numbers belong to each patient in the experiment. One way to
| do this is to add a column to the matrix, which contains the names of all four people.

...

  |========================================================================================                                                                      |  56%
| Let's start by creating a character vector containing the names of our patients -- Bill, Gina, Kelly, and Sean.
| Remember that double quotes tell R that something is a character string. Store the result in a variable called
| patients.

> patients <- c("Bill","Gina","Kelly","Sean")

| Great job!

  |============================================================================================                                                                  |  58%
| Now we'll use the cbind() function to 'combine columns'. Don't worry about storing the result in a new variable.
| Just call cbind() with two arguments -- the patients vector and my_matrix.

> cbind(patients,my_matrix)
     patients                       
[1,] "Bill"   "1" "5" "9"  "13" "17"
[2,] "Gina"   "2" "6" "10" "14" "18"
[3,] "Kelly"  "3" "7" "11" "15" "19"
[4,] "Sean"   "4" "8" "12" "16" "20"

| That's correct!

  |=================================================================================================                                                             |  61%
| Something is fishy about our result! It appears that combining the character vector with our matrix of numbers
| caused everything to be enclosed in double quotes. This means we're left with a matrix of character strings, which
| is no good.

...

  |=====================================================================================================                                                         |  64%
| If you remember back to the beginning of this lesson, I told you that matrices can only contain ONE class of data.
| Therefore, when we tried to combine a character vector with a numeric matrix, R was forced to 'coerce' the numbers
| to characters, hence the double quotes.

...

  |=========================================================================================================                                                     |  67%
| This is called 'implicit coercion', because we didn't ask for it. It just happened. But why didn't R just convert
| the names of our patients to numbers? I'll let you ponder that question on your own.

...

  |==============================================================================================================                                                |  69%
| So, we're still left with the question of how to include the names of our patients in the table without destroying
| the integrity of our numeric data. Try the following -- my_data <- data.frame(patients, my_matrix)

> my_data <- data.frame(patients,my_matrix)

| You're the best!

  |==================================================================================================================                                            |  72%
| Now view the contents of my_data to see what we've come up with.

> my_data
  patients X1 X2 X3 X4 X5
1     Bill  1  5  9 13 17
2     Gina  2  6 10 14 18
3    Kelly  3  7 11 15 19
4     Sean  4  8 12 16 20

| Your dedication is inspiring!

  |======================================================================================================================                                        |  75%
| It looks like the data.frame() function allowed us to store our character vector of names right alongside our
| matrix of numbers. That's exactly what we were hoping for!

...

  |===========================================================================================================================                                   |  78%
| Behind the scenes, the data.frame() function takes any number of arguments and returns a single object of class
| `data.frame` that is composed of the original objects.

...

  |===============================================================================================================================                               |  81%
| Let's confirm this by calling the class() function on our newly created data frame.

> class(my_data)
[1] "data.frame"

| That's a job well done!

  |====================================================================================================================================                          |  83%
| It's also possible to assign names to the individual rows and columns of a data frame, which presents another
| possible way of determining which row of values in our table belongs to each patient.

...

  |========================================================================================================================================                      |  86%
| However, since we've already solved that problem, let's solve a different problem by assigning names to the columns
| of our data frame so that we know what type of measurement each column represents.

...

  |============================================================================================================================================                  |  89%
| Since we have six columns (including patient names), we'll need to first create a vector containing one element for
| each column. Create a character vector called cnames that contains the following values (in order) -- "patient",
| "age", "weight", "bp", "rating", "test".

> cnames <- c("age","weight","bb","rating","test")

| Try again. Getting it right on the first try is boring anyway! Or, type info() for more options.

| Make sure all of the names are lowercase, surrounded by double quotes, and separated with commas. Don't forget to
| use the c() function.

> cnames <- c("patient","age","weight","bb","rating","test")

| Nice try, but that's not exactly what I was hoping for. Try again. Or, type info() for more options.

| Make sure all of the names are lowercase, surrounded by double quotes, and separated with commas. Don't forget to
| use the c() function.

> cnames <- c("patient","age","weight","bp","rating","test")

| You are really on a roll!

  |=================================================================================================================================================             |  92%
| Now, use the colnames() function to set the `colnames` attribute for our data frame. This is similar to the way we
| used the dim() function earlier in this lesson.

> colnames(my_data) <- cnames

| Excellent work!

  |=====================================================================================================================================================         |  94%
| Let's see if that got the job done. Print the contents of my_data.

> my_data
  patient age weight bp rating test
1    Bill   1      5  9     13   17
2    Gina   2      6 10     14   18
3   Kelly   3      7 11     15   19
4    Sean   4      8 12     16   20

| Perseverance, that's the answer.

  |==========================================================================================================================================================    |  97%
| In this lesson, you learned the basics of working with two very important and common data structures -- matrices
| and data frames. There's much more to learn and we'll be covering more advanced topics, particularly with respect
| to data frames, in future lessons.

...

  |==============================================================================================================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: No
2: Yes

Selection: 1

| That's the answer I was looking for.

| You've reached the end of this lesson! Returning to the main menu...

| Would you like to continue with one of these lessons?

1: R Programming Subsetting Vectors
2: No. Let me start something new.

Selection: 2

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers    
 4: Vectors                    5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                      9: Functions               
10: lapply and sapply         11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times           15: Base Graphics           


Selection: 9

  |                                                                                                            |   0%

| Functions are one of the fundamental building blocks of the R language. They are small pieces of reusable code that
| can be treated like any other R object.

...

  |==                                                                                                          |   2%
| If you've worked through any other part of this course, you've probably used some functions already. Functions are
| usually characterized by the name of the function followed by parentheses.

...

  |====                                                                                                        |   4%
| Let's try using a few basic functions just for fun. The Sys.Date() function returns a string representing today's
| date. Type Sys.Date() below and see what happens.

> Sys.Date()
[1] "2018-09-26"

| You are doing so well!

  |=======                                                                                                     |   6%
| Most functions in R return a value. Functions like Sys.Date() return a value based on your computer's environment,
| while other functions manipulate input data in order to compute a return value.

...

  |=========                                                                                                   |   8%
| The mean() function takes a vector of numbers as input, and returns the average of all of the numbers in the input
| vector. Inputs to functions are often called arguments. Providing arguments to a function is also sometimes called
| passing arguments to that function. Arguments you want to pass to a function go inside the function's parentheses.
| Try passing the argument c(2, 4, 5) to the mean() function.

> mean(c(2,4,5))
[1] 3.666667

| You are amazing!

  |===========                                                                                                 |  10%
| Functions usually take arguments which are variables that the function operates on. For example, the mean()
| function takes a vector as an argument, like in the case of mean(c(2,6,8)). The mean() function then adds up all of
| the numbers in the vector and divides that sum by the length of the vector.

...

  |=============                                                                                               |  12%
| In the following question you will be asked to modify a script that will appear as soon as you move on from this
| question. When you have finished modifying the script, save your changes to the script and type submit() and the
| script will be evaluated. There will be some comments in the script that opens up, so be sure to read them!

...

  |===============                                                                                             |  14%
| The last R expression to be evaluated in a function will become the return value of that function. We want this
| function to take one argument, x, and return x without modifying it. Delete the pound sign so that x is returned
| without any modification. Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| That's correct!

  |==================                                                                                          |  16%
| Now that you've created your first function let's test it! Type: boring_function('My first function!'). If your
| function works, it should just return the string: 'My first function!'

> boring_function("Goodbye World, Goodbye Yellow Brick Road, Goodbye Horses!")
[1] "Goodbye World, Goodbye Yellow Brick Road, Goodbye Horses!"

| Give it another try. Or, type info() for more options.

| Test boring_function by typing: boring_function('My first function!')

> boring_function("My first function!")
[1] "My first function!"

| You are quite good my friend!

  |====================                                                                                        |  18%
| Congratulations on writing your first function. By writing functions, you can gain serious insight into how R
| works. As John Chambers, the creator of R once said:
| 
| To understand computations in R, two slogans are helpful: 1. Everything that exists is an object. 2. Everything
| that happens is a function call.

...

  |======================                                                                                      |  20%
| If you want to see the source code for any function, just type the function name without any arguments or
| parentheses. Let's try this out with the function you just created. Type: boring_function to view its source code.

> boring_function
function(x) {
  x
}
<bytecode: 0x547cc08>

| All that hard work is paying off!

  |========================                                                                                    |  22%
| Time to make a more useful function! We're going to replicate the functionality of the mean() function by creating
| a function called: my_mean(). Remember that to calculate the average of all of the numbers in a vector you find the
| sum of all the numbers in the vector, and then divide that sum by the number of numbers in the vector.

...

  |==========================                                                                                  |  24%
| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| You are really on a roll!

  |=============================                                                                               |  27%
| Now test out your my_mean() function by finding the mean of the vector c(4, 5, 10).

> my_mean(c(4,5,10))
[1] 6.333333

| That's correct!

  |===============================                                                                             |  29%
| Next, let's try writing a function with default arguments. You can set default values for a function's arguments,
| and this can be useful if you think someone who uses your function will set a certain argument to the same value
| most of the time.

...

  |=================================                                                                           |  31%
| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| You're the best!

  |===================================                                                                         |  33%
| Let's do some testing of the remainder function. Run remainder(5) and see what happens.

> remainder(5)
[1] 1

| Excellent job!

  |=====================================                                                                       |  35%
| Let's take a moment to examine what just happened. You provided one argument to the function, and R matched that
| argument to 'num' since 'num' is the first argument. The default value for 'divisor' is 2, so the function used the
| default value you provided.

...

  |========================================                                                                    |  37%
| Now let's test the remainder function by providing two arguments. Type: remainder(11, 5) and let's see what
| happens.

> remainder(11,5)
[1] 1

| You are quite good my friend!

  |==========================================                                                                  |  39%
| Once again, the arguments have been matched appropriately.

...

  |============================================                                                                |  41%
| You can also explicitly specify arguments in a function. When you explicitly designate argument values by name, the
| ordering of the arguments becomes unimportant. You can try this out by typing: remainder(divisor = 11, num = 5).

>  remainder(divisor = 11, num = 5)
[1] 5

| You are really on a roll!

  |==============================================                                                              |  43%
| As you can see, there is a significant difference between remainder(11, 5) and remainder(divisor = 11, num = 5)!

...

  |================================================                                                            |  45%
| R can also partially match arguments. Try typing remainder(4, div = 2) to see this feature in action.

> remainder(4,div = 2)
[1] 0

| You are quite good my friend!

  |===================================================                                                         |  47%
| A word of warning: in general you want to make your code as easy to understand as possible. Switching around the
| orders of arguments by specifying their names or only using partial argument names can be confusing, so use these
| features with caution!

...

  |=====================================================                                                       |  49%
| With all of this talk about arguments, you may be wondering if there is a way you can see a function's arguments
| (besides looking at the documentation). Thankfully, you can use the args() function! Type: args(remainder) to
| examine the arguments for the remainder function.

> args(remainder)
function (num, divisor = 2) 
NULL

| Excellent job!

  |=======================================================                                                     |  51%
| You may not realize it but I just tricked you into doing something pretty interesting! args() is a function,
| remainder() is a function, yet remainder was an argument for args(). Yes it's true: you can pass functions as
| arguments! This is a very powerful concept. Let's write a script to see how it works.

...

  |=========================================================                                                   |  53%
| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| Your dedication is inspiring!

  |============================================================                                                |  55%
| Let's take your new evaluate() function for a spin! Use evaluate to find the standard deviation of the vector
| c(1.4, 3.6, 7.9, 8.8).

> evaluate(sd,c(1.4,3.6,7.9,8.8))
[1] 3.514138

| That's a job well done!

  |==============================================================                                              |  57%
| The idea of passing functions as arguments to other functions is an important and fundamental concept in
| programming.

...

  |================================================================                                            |  59%
| You may be surprised to learn that you can pass a function as an argument without first defining the passed
| function. Functions that are not named are appropriately known as anonymous functions.

...

  |==================================================================                                          |  61%
| Let's use the evaluate function to explore how anonymous functions work. For the first argument of the evaluate
| function we're going to write a tiny function that fits on one line. In the second argument we'll pass some data to
| the tiny anonymous function in the first argument.

...

  |====================================================================                                        |  63%
| Type the following command and then we'll discuss how it works: evaluate(function(x){x+1}, 6)

> evaluate(function(x){x+1},6)
[1] 7

| All that hard work is paying off!

  |=======================================================================                                     |  65%
| The first argument is a tiny anonymous function that takes one argument `x` and returns `x+1`. We passed the number
| 6 into this function so the entire expression evaluates to 7.

...

  |=========================================================================                                   |  67%
| Try using evaluate() along with an anonymous function to return the first element of the vector c(8, 4, 0). Your
| anonymous function should only take one argument which should be a variable `x`.

> evaluate(function(x){x[1]},c(8,4,0))
[1] 8

| Perseverance, that's the answer.

  |===========================================================================                                 |  69%
| Now try using evaluate() along with an anonymous function to return the last element of the vector c(8, 4, 0). Your
| anonymous function should only take one argument which should be a variable `x`.

> evaluate(function(x){x[3]},c(8,4,0))
[1] 0

| Keep trying! Or, type info() for more options.

| You may need to recall how to index vector elements. Remember that your anonymous function should only have one
| argument, and that argument should be named `x`. Using the length() function in your anonymous function may help
| you.

> evaluate(function(x){x[length(x)]},c(8,4,0))
[1] 0

| You nailed it! Good job!

  |=============================================================================                               |  71%
| For the rest of the course we're going to use the paste() function frequently. Type ?paste so we can take a look at
| the documentation for the paste function.

> ?paste

| All that hard work is paying off!

  |===============================================================================                             |  73%
| As you can see the first argument of paste() is `...` which is referred to as an ellipsis or simply dot-dot-dot.
| The ellipsis allows an indefinite number of arguments to be passed into a function. In the case of paste() any
| number of strings can be passed as arguments and paste() will return all of the strings combined into one string.

...

  |==================================================================================                          |  76%
| Just to see how paste() works, type paste("Programming", "is", "fun!")

> paste("Programming","is","fun!")
[1] "Programming is fun!"

| You are amazing!

  |====================================================================================                        |  78%
| Time to write our own modified version of paste().

...

  |======================================================================================                      |  80%
| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| Almost! Try again.

| Remember that arguments can come after ...

> submit()

| Sourcing your script...


| Give it another try.

| Remember that arguments can come after ...

> submit()

| Sourcing your script...


| Give it another try.

| Remember that arguments can come after ...

> skip
function () 
{
    invisible()
}
<environment: namespace:swirl>
> 
> swirl()

| Welcome to swirl! Please sign in. If you've been here before, use the same name as you did then. If you are new,
| call yourself something unique.

What shall I call you? Sean

| Would you like to continue with one of these lessons?

1: R Programming Functions
2: R Programming Subsetting Vectors
3: No. Let me start something new.

Selection: 3

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers    
 4: Vectors                    5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                      9: Functions               
10: lapply and sapply         11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times           15: Base Graphics           


Selection:
